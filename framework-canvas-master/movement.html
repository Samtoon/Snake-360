<canvas id="canvas" width="300" height="300"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/functional-light.js"></script>
<script>
  //Vamos a usar http://processingjs.org/

  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;
  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  }
  function puntdif()
  {
    switch (chosendif)
    {
      case difficulty.millipede:
        return "PuntajeM";
        break;
      case difficulty.snake:
        return "PuntajeS";
        break;
      case difficulty.centipede:
        return "PuntajeC";
        break;
    }
  }
  function invertir(list)
  {
    if(isEmpty(list))
    {
      return [];
    }
    return cons(last(list),invertir(restLast(list)));
  }
  function contain(x,list)
  {
    if(isEmpty(list))
    {
      return false;
    }
    if (x==first(list))
    {
      return true;
    }
    return contain(x,(rest(list)));
  }
  function restLast(list)
  {
    if(length(list)==1)
    {
      return [];
    }
    return cons(first(list),restLast(rest(list)));
  }
 
  function Pit(val)
  {
    return Math.sqrt(Math.pow(speed,2)-Math.pow(val,2));
  }
  function Redondear(val)
  {
    if(Math.ceil(val)-val<val-Math.floor(val))
    {
      return Math.ceil(val);
    }
    return Math.floor(val);
  }
  function midval(val)
  {
    return Redondear(Math.sqrt(Math.pow(val,2)/2));
  }
  function reSnake(snake,dir,x,y)
  {
    if(isEmpty(snake))
    {
      return [];
    }
    if(first(snake).x>=window.innerWidth)
    {
      return cons({x: 0 + first(snake).dirección.x, y: first(snake).y + first(snake).dirección.y, dirección: dir,distance: Distance(x,y,first(snake).x,first(snake).y)}, reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).x<=0)
    {
      return cons({x: window.innerWidth + first(snake).dirección.x, y: first(snake).y + first(snake).dirección.y, dirección: dir,distance: Distance(x,y,first(snake).x,first(snake).y)}, reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).y>=window.innerHeight)
    {
      return cons({x: first(snake).x + first(snake).dirección.x, y: 0 + first(snake).dirección.y, dirección: dir,distance: Distance(x,y,first(snake).x,first(snake).y)}, reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).y<=0)
    {
      return cons({x: first(snake).x + first(snake).dirección.x, y: window.innerHeight + first(snake).dirección.y, dirección: dir,distance: Distance(x,y,first(snake).x,first(snake).y)}, reSnake(rest(snake),first(snake).dirección,x,y));
    }
    return cons({x: first(snake).x + first(snake).dirección.x, y: first(snake).y + first(snake).dirección.y, dirección: dir,distance: Distance(x,y,first(snake).x,first(snake).y)}, reSnake(rest(snake),first(snake).dirección,x,y));
  }
  function last(list)
  {
    if(length(list)==1)
    {
      return first(list);
    }
    return last(rest(list));
  }
  function opposite(val)
  {
    return -val;
  }
  function Distance(x1,y1,x2,y2)
  {
    return Redondear(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)));
  }
  function Movement(world,a,val1,val2)
  {
    if(a==="y")
    {
      return make(world, {dirección: {y: world.dirección.y + world.twist*val1,x: Redondear(Pit(world.dirección.y+val1*world.twist))*val2}, snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y),movement: 1});
    }
    else if(a==="x"){
      return make(world, {dirección: {x: world.dirección.x + world.twist*val1,y: Redondear(Pit(world.dirección.x+val1*world.twist))*val2}, snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y),movement: 2});
    }
    else if(a==="nothing"){
      return make(world, {snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y), movement: 3});
    }
  }
  function selfColission(snake,head)
  {
    if (isEmpty(snake))
    {
      return false;
    }
    if (Distance(head.x,head.y,first(snake).x,first(snake).y)<normdistance)
    {
      return true;
    }
    return selfColission(rest(snake),head);
  }
  const size=10;
  const difficulty={millipede: {speed: size*0.5, twist: 1}, snake: {speed: size*0.75, twist: 1.5}, centipede: {speed: size, twist: 2}};
  const chosendif=difficulty.snake;
  const speed=chosendif.speed
  const snake=[{x: 100, y:100, dirección: {x: speed,y: 0}, distance: 20},{x: 100-speed, y:100, dirección: {x: speed,y: 0}, distance: 20},{x: 100-2*speed, y:100, dirección: {x: speed,y: 0}, distance: 20},{x: 100-3*speed, y:100, dirección: {x: speed,y: 0}, distance: 20}]
  const normdistance=Distance(snake[0].x,snake[0].y,snake[1].x,snake[1].y);
  function sketchProc(processing) {

    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      document.getElementById("canvas").focus();
      processing.frameRate(30);
      processing.size(window.innerWidth-20, window.innerHeight-20);
      processing.background(10, 200, 50);
      processing.state = {index: 0,plump:[-1] ,eat: false,over: false,kill: false, x: 100, y: 100, ancho: size, alto: size ,dirección: {x: speed, y:0},snake: snake,keydown:false,key:processing.LEFT,food: {x: processing.random(50, window.innerWidth-70) ,y: processing.random(50, window.innerHeight-70)},score: 0,twist: chosendif.twist, distance: 20,movement: false};
      
    }

    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo stado del mundo
    */
    processing.onTic = function (world) {
      if(world.keydown){
        switch (world.key) {
        
        
        case processing.LEFT:
        
          if (world.dirección.x>0&&world.dirección.x<=speed&&world.dirección.y<=0)
        {
          if(world.dirección.y>-midval(speed))
          {
            return Movement(world,"y",-1,1);
          }
          return Movement(world,"x",-1,-1);
        }
        if (world.dirección.y<0&&world.dirección.y>=-speed)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return Movement(world,"x",-1,-1);
          }
          return Movement(world,"y",1,-1);
        }
        if (world.dirección.x<0&&world.dirección.x>=-speed)
        {
          if(world.dirección.y<midval(speed)&&world.dirección.y>=0)
          {
            return Movement(world,"y",1,-1);
          }
          return Movement(world,"x",1,1);
        }
        if (world.dirección.y>0&&world.dirección.y<=speed)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return Movement(world,"x",1,1);
          }
          return Movement(world,"y",-1,1);
        }
        
        break;
        case processing.RIGHT:
        if (world.dirección.x>0&&world.dirección.x<=speed&&world.dirección.y>=0)
        {
          if(world.dirección.y<midval(speed))
          {
            return Movement(world,"y",1,1);
          }
          return Movement(world,"x",-1,1);
        }
        if (world.dirección.y>0&&world.dirección.y<=speed)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return Movement(world,"x",-1,1);
          }
          return Movement(world,"y",-1,-1);
        }
        if (world.dirección.x<0&&world.dirección.x>=-speed)
        {
          if(world.dirección.y>-midval(speed)&&world.dirección.y<=0)
          {
            return Movement(world,"y",-1,-1);
          }
          return Movement(world,"x",1,-1);
        }
        if (world.dirección.y<0&&world.dirección.y>=-speed)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return Movement(world,"x",1,-1);
          }
          return Movement(world,"y",1,1);
        }
          break;
       
        
      }
      }
      return Movement(world,"nothing",null,null);
      
    }

    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch(keyCode)
      {
        case processing.UP:
          processing.loop();
          return make(world, {});
          break;
        case processing.DOWN:
          processing.textSize(100)
          processing.text("PAUSE", window.innerWidth/3, window.innerHeight/2);
          processing.noLoop();
          return make(world, {});
          break;
          case 107:
          return make(world, { alto: world.alto + size });
          break;
        case 109:
          return make(world, { alto: world.alto - size });
          break;
        case 32:
          return make(world, {snake: append(world.snake,[{x: last(world.snake).x+opposite(last(world.snake).dirección.x), y:last(world.snake).y+opposite(last(world.snake).dirección.y), dirección: last(world.snake).dirección}])})
        default:
        return make(world, {keydown: true, key:keyCode});
      }
      
    }
     processing.drawSnake = function (item)
  {
    if(!processing.state.kill)
    {
    processing.fill(245, 140, 42);
  }
  else{
    processing.fill(158, 155, 147);
  }
    processing.ellipse(item.x,item.y,size,size);
  }
  processing.eatSnake = function(item,index,array)
  {
    if(!processing.state.kill)
    {
    processing.fill(245, 140, 42);
  }
  else{
    processing.fill(158, 155, 147);
  }
    if(contain(index,processing.state.plump))
    {
      if(index==length(array)-1)
      {
        if(length(processing.state.plump)>1)
        {
          processing.state = make(processing.state, {plump: rest(processing.state.plump)});
        }
        else{
          processing.state = make(processing.state, {plump: [-1],eat: false});
        }
        processing.ellipse(item.x,item.y,size,size);
      processing.state = make(processing.state, {index: index,snake: append(processing.state.snake,[{x: last(processing.state.snake).x+opposite(last(processing.state.snake).dirección.x), y:last(processing.state.snake).y+opposite(last(processing.state.snake).dirección.y), dirección: last(processing.state.snake).dirección, distance: 0}])});
      }
      else{
      processing.ellipse(item.x,item.y,size*1.5-(index*size*0.5)/length(array),size*1.5-(index*size*0.5)/length(array));
      }
      
    }
    
    else{
    processing.ellipse(item.x,item.y,size,size);
    }
  }
  processing.desintegrate = function (world)
  { 
    if (length(world.snake)==1)
    {
      processing.state = make(world, {over: true});
    }
    else{
    processing.state = make(world, {snake: restLast(world.snake)});
    processing.loop();
    }
    

  }
  processing.stop = function (item)
  {
    return make(item, {dirección: {x: 0,y: 0}});
  }
  processing.check = function (key)
  {
    if (window.localStorage.getItem(key)==null)
    {
      window.localStorage.setItem(puntdif(),"0");
    }
  }
 
 
  processing.offKeyEvent = function (world, keyCode){
    return make(world, {keydown: false, key:keyCode});
  }

    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world, txt) {
      processing.check(puntdif());
      if (world.score>parseInt(window.localStorage.getItem(puntdif())))
      {
        window.localStorage.setItem(puntdif(),""+world.score);
      }
      if (world.over==false)
      {
        processing.background(10, 200, 50);
      processing.fill(240, 240, 240);
      processing.state = make(world, {})
      if (selfColission(rest(world.snake),world.snake[0])&&world.kill==false)
      {
        processing.state = make(world, {eat: false,snake: world.snake.map(processing.stop), dirección: {x: 0, y: 0}});
        setTimeout(function(){processing.state=make(world, {kill: true})}, 1000);
      }
      if (world.distance<=size*2)
      {
        processing.state = make(world, {eat: true,score:world.score+100,food: {x: processing.random(50, window.innerWidth-70) ,y: processing.random(50, window.innerHeight-70)},distance: 10});
      }
      if (world.kill)
      {
          processing.desintegrate(world);
      }
      if(world.eat)
      {
        processing.state = make(world,{plump: world.plump.map((x)=> x+1)});
        world.snake.forEach(processing.eatSnake);
        if (selfColission(rest(world.snake),world.snake[0])&&world.kill==false)
      {
        processing.state = make(world, {eat: false,snake: world.snake.map(processing.stop), dirección: {x: 0, y: 0}});
        processing.fill(158, 155, 147)
        setTimeout(function(){processing.state=make(world, {kill: true})}, 1000);
      }
      if (world.distance<=size*2)
      {
        processing.state = make(world, {plump: invertir(cons(-1,invertir(world.plump))),score:world.score+100,food: {x: processing.random(50, window.innerWidth-70) ,y: processing.random(50, window.innerHeight-70)},distance: 10});

      }
      
        
      }
      else{
      world.snake.forEach(processing.drawSnake);
      }
      if (world.eat)
      {
        processing.fill(252, 114, 114);
      }
      else
      {
      processing.fill(245, 42, 42);
      }

      processing.ellipse(world.food.x,world.food.y,size*3,size*3);
      processing.textSize(20)
      processing.text(txt, 50, 200);
      processing.text("SCORE: "+world.score, 10, 30);
      processing.text("BEST SCORE: "+window.localStorage.getItem(puntdif()), 10, 70);
      }
      else
      {
        setTimeout(function(){
        processing.background(0,0,0);
        processing.textSize(150)
          processing.text("GAME OVER", window.innerWidth/6, window.innerHeight/2);
        },500);
      }
      
    }


    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state, processing.state.plump);
      processing.state = processing.onTic(processing.state);
    };

    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      if (!processing.state.over)
      {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
      }
    }

    processing.keyReleased = function () {
      processing.state = processing.offKeyEvent(processing.state, processing.keyCode);
    }

    
    
  }

  var canvas = document.getElementById("canvas");

  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>
