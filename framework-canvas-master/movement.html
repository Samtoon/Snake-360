<canvas id="canvas" width="300" height="300"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/functional-light.js"></script>
<script>
  //Vamos a usar http://processingjs.org/

  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;

  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  }
  
  function Pit(val)
  {
    return Math.sqrt(Math.pow(speed,2)-Math.pow(val,2));
  }
  function Redondear(val)
  {
    if(Math.ceil(val)-val<val-Math.floor(val))
    {
      return Math.ceil(val);
    }
    return Math.floor(val);
  }
  function midval(val)
  {
    return Redondear(Math.sqrt(Math.pow(val,2)/2));
  }
  function reSnake(snake,dir)
  {
    if(isEmpty(snake))
    {
      return [];
    }
    return cons({x: first(snake).x + first(snake).dirección.x, y: first(snake).y + first(snake).dirección.y, dirección: dir},reSnake(rest(snake),first(snake).dirección));
  }
  function last(list)
  {
    if(length(list)==1)
    {
      return first(list);
    }
    return last(rest(list));
  }
  function opposite(val)
  {
    return -val;
  }
  function Distance(x1,y1,x2,y2)
  {
    return Redondear(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)));
  }
  const size=10;
  const speed=size;
  const snake=[{x: 100, y:100, dirección: {x: speed,y: 0}},{x: 100-size, y:100, dirección: {x: speed,y: 0}},{x: 100-2*size, y:100, dirección: {x: speed,y: 0}},{x: 100-3*size, y:100, dirección: {x: speed,y: 0}}]
  function sketchProc(processing) {

    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      processing.frameRate(30);
      processing.size(window.innerWidth-20, window.innerHeight-20);
      processing.background(10, 200, 50);
      processing.state = { x: 100, y: 100, ancho: size, alto: size ,dirección: {x: speed, y:0},snake: snake,keydown:false,key:processing.LEFT,food: {x: processing.random(50, window.innerWidth-70) ,y: processing.random(50, window.innerHeight-70)},score: 0,twist: 1, distance: 10};
      
    }

    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo stado del mundo
    */
    processing.onTic = function (world) {
      if(world.keydown){
        switch (world.key) {
        
        
        case processing.LEFT:
        
          if (world.dirección.x>0&&world.dirección.x<=speed&&world.dirección.y<=0)
        {
          if(world.dirección.y>-midval(speed))
          {
            return make(world, {dirección: {y: world.dirección.y - world.twist,x: Redondear(Pit(world.dirección.y-world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {y: -Redondear(Pit(world.dirección.x-world.twist)),x: world.dirección.x-world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.y<0&&world.dirección.y>=-speed)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return make(world, {dirección: {x: world.dirección.x - world.twist,y: -Redondear(Pit(world.dirección.x-world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {x: -Redondear(Pit(world.dirección.y+world.twist)),y: world.dirección.y+world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.x<0&&world.dirección.x>=-speed)
        {
          if(world.dirección.y<midval(speed)&&world.dirección.y>=0)
          {
            return make(world, {dirección: {y: world.dirección.y + world.twist,x: -Redondear(Pit(world.dirección.y+world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {y: Redondear(Pit(world.dirección.x+world.twist)),x: world.dirección.x+world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.y>0&&world.dirección.y<=speed)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return make(world, {dirección: {x: world.dirección.x + world.twist,y: Redondear(Pit(world.dirección.x+world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {x: Redondear(Pit(world.dirección.y-world.twist)),y: world.dirección.y-world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        
        break;
        case processing.RIGHT:
        if (world.dirección.x>0&&world.dirección.x<=speed&&world.dirección.y>=0)
        {
          if(world.dirección.y<midval(speed))
          {
            return make(world, {dirección: {y: world.dirección.y + world.twist,x: Redondear(Pit(world.dirección.y+world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {y: Redondear(Pit(world.dirección.x-world.twist)),x: world.dirección.x-world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.y>0&&world.dirección.y<=speed)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return make(world, {dirección: {x: world.dirección.x - world.twist,y: Redondear(Pit(world.dirección.x-world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {x: -Redondear(Pit(world.dirección.y-world.twist)),y: world.dirección.y-world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.x<0&&world.dirección.x>=-speed)
        {
          if(world.dirección.y>-midval(speed)&&world.dirección.y<=0)
          {
            return make(world, {dirección: {y: world.dirección.y - world.twist,x: -Redondear(Pit(world.dirección.y-world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {y: -Redondear(Pit(world.dirección.x+world.twist)),x: world.dirección.x+world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
        if (world.dirección.y<0&&world.dirección.y>=-speed)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return make(world, {dirección: {x: world.dirección.x + world.twist,y: -Redondear(Pit(world.dirección.x+world.twist))}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
          }
          return make(world, {dirección: {x: Redondear(Pit(world.dirección.y+world.twist)),y: world.dirección.y+world.twist}, snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
        }
          break;
       
        
      }
      }
      return make(world, {snake: reSnake(world.snake,world.dirección), distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
      
    }

    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch(keyCode)
      {
        case processing.UP:
          processing.loop();
          return make(world, {});
          break;
        case processing.DOWN:
          processing.textSize(100)
          processing.text("PAUSE", window.innerWidth/3, window.innerHeight/2);
          processing.noLoop();
          return make(world, {});
          break;
          case 107:
          return make(world, { alto: world.alto + size });
          break;
        case 109:
          return make(world, { alto: world.alto - size });
          break;
        case 32:
          return make(world, {snake: append(world.snake,[{x: last(world.snake).x+opposite(last(world.snake).dirección.x), y:last(world.snake).y+opposite(last(world.snake).dirección.y), dirección: last(world.snake).dirección}])})
        default:
        return make(world, {keydown: true, key:keyCode});
      }
      
    }
     processing.drawSnake = function (item)
  {
    processing.ellipse(item.x,item.y,size,size);
  }
  processing.offKeyEvent = function (world, keyCode){
    return make(world, {keydown: false, key:keyCode});
  }

    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world, txt) {
      processing.background(10, 200, 50);
      processing.fill(240, 240, 240);
      if (world.distance<=size*0.75)
      {
        processing.state = make(world, {score:world.score+100,food: {x: processing.random(50, window.innerWidth-70) ,y: processing.random(50, window.innerHeight-70)},distance: 10,snake: append(world.snake,[{x: last(world.snake).x+opposite(last(world.snake).dirección.x), y:last(world.snake).y+opposite(last(world.snake).dirección.y), dirección: last(world.snake).dirección}])});
      }
      world.snake.forEach(processing.drawSnake);
      processing.ellipse(world.food.x,world.food.y,size,size);
      processing.text(txt, 50, 200);
      processing.text("SCORE: "+world.score, 10, 10);
      
    }


    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state, processing.state.distance);
      processing.state = processing.onTic(processing.state);
    };

    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
    }

    processing.keyReleased = function () {
      processing.state = processing.offKeyEvent(processing.state, processing.keyCode);
    }

    
    
  }

  var canvas = document.getElementById("canvas");

  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>