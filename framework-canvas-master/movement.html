<canvas id="canvas" width="300" height="300"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/functional-light.js"></script>
<script>
  //Vamos a usar http://processingjs.org/

  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;
  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  }
  function puntdif()
  {
    switch (chosendif)
    {
      case difficulty.millipede:
        return "PuntajeM";
        break;
      case difficulty.snake:
        return "PuntajeS";
        break;
      case difficulty.centipede:
        return "PuntajeC";
        break;
    }
  }
  function invertir(list)
  {
    if(isEmpty(list))
    {
      return [];
    }
    return cons(last(list),invertir(restLast(list)));
  }
  function contain(x,list)
  {
    if(isEmpty(list))
    {
      return false;
    }
    if (x==first(list))
    {
      return true;
    }
    return contain(x,(rest(list)));
  }
  function restLast(list)
  {
    if(length(list)==1)
    {
      return [];
    }
    return cons(first(list),restLast(rest(list)));
  }
 
  function Pit(val)
  {
    return Math.sqrt(Math.pow(speed,2)-Math.pow(val,2));
  }
  function Redondear(val)
  {
    if(Math.ceil(val)-val<val-Math.floor(val))
    {
      return Math.ceil(val);
    }
    return Math.floor(val);
  }
  function midval(val)
  {
    return Redondear(Math.sqrt(Math.pow(val,2)/2));
  }
  function reSnake(snake,dir,x,y)
  {
    if(isEmpty(snake))
    {
      return [];
    }
    if(first(snake).x>=window.innerWidth)
    {
      return cons({x: 0 + first(snake).dirección.x,
      y: first(snake).y + first(snake).dirección.y, 
      dirección: dir,
      distance: Distance(x,y,first(snake).x,first(snake).y)}, 
      reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).x<=0)
    {
      return cons({x: window.innerWidth + first(snake).dirección.x,
      y: first(snake).y + first(snake).dirección.y,
      dirección: dir,
      distance: Distance(x,y,first(snake).x,first(snake).y)},
      reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).y>=window.innerHeight)
    {
      return cons({x: first(snake).x + first(snake).dirección.x,
      y: 0 + first(snake).dirección.y,
      dirección: dir,
      distance: Distance(x,y,first(snake).x,first(snake).y)},
      reSnake(rest(snake),first(snake).dirección,x,y));
    }
    if(first(snake).y<=0)
    {
      return cons({x: first(snake).x + first(snake).dirección.x,
      y: window.innerHeight + first(snake).dirección.y,
      dirección: dir,
      distance: Distance(x,y,first(snake).x,first(snake).y)},
      reSnake(rest(snake),first(snake).dirección,x,y));
    }
    return cons({x: first(snake).x + first(snake).dirección.x,
    y: first(snake).y + first(snake).dirección.y,
    dirección: dir,
    distance: Distance(x,y,first(snake).x,first(snake).y)},
    reSnake(rest(snake),first(snake).dirección,x,y));
  }
  function last(list)
  {
    if(length(list)==1)
    {
      return first(list);
    }
    return last(rest(list));
  }
  function opposite(val)
  {
    return -val;
  }
  function Distance(x1,y1,x2,y2)
  {
    return Redondear(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2)));
  }
  function Movement(world,a,val1,val2)
  {
    if(a==="y")
    {
      return make(world,
      {dirección: 
      {y: world.dirección.y + world.twist*val1,
      x: Redondear(Pit(world.dirección.y+val1*world.twist))*val2},
      snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y),
      distance: Distance(world.snake[0].x,world.snake[0].y,world.food.x,world.food.y)});
    }
    else if(a==="x"){
      return make(world,
      {dirección:
      {x: world.dirección.x + world.twist*val1,
      y: Redondear(Pit(world.dirección.x+val1*world.twist))*val2},
      snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y),
      distance: Distance(world.snake[0].x,world.snake[0].y,world.food.x,world.food.y)});
    }
    else if(a==="nothing"){
      return make(world,
      {snake: reSnake(world.snake,world.dirección,world.snake[0].x,world.snake[0].y),
      distance: Distance(world.snake[0].x,world.snake[0].y, world.food.x,world.food.y)});
    }
  }
  function selfColission(snake,head)
  {
    if (isEmpty(snake))
    {
      return false;
    }
    if (Distance(head.x,head.y,first(snake).x,first(snake).y)<normdistance)
    {
      return true;
    }
    return selfColission(rest(snake),head);
  }
  // Aquí se definen el tamaño de los segmentos, las posibles dificultades y sus velocidades y twists correspondientes
  /* Twist: Cantidad en que aumenta o disminuye X o Y a la hora de girar.
  Esto define qué tan rápido puede dar una vuelta completa:
  entre más pequeño sea el valor, menos aumentan X o Y cuando se presionan las teclas,
  y se tarda más tiempo en girar; entre más grande, más aumentan y se tarda menos.
  */
  const size=10;
  const difficulty={millipede: {speed: size*0.5, twist: 1},
                    snake: {speed: size*0.75, twist: 1.5},
                    centipede: {speed: size, twist: 2}};
  //La dificultad seleccionada. La velocidad y el twist del snake dependen de este valor.
  const chosendif=difficulty.snake;
  const speed=chosendif.speed
  //La snake inicial, que consta de 4 segmentos en una línea horizontal uno detrás del otro.
  const snake=[{x: 100, y:100, dirección: {x: speed,y: 0}, distance: 20},
              {x: 100-speed, y:100, dirección: {x: speed,y: 0}, distance: 20},
              {x: 100-2*speed, y:100, dirección: {x: speed,y: 0}, distance: 20},
              {x: 100-3*speed, y:100, dirección: {x: speed,y: 0}, distance: 20}]
  /*La distancia mínima de cada segmento con la cabeza del snake.
  Si la distancia de uno de los segmentos con la cabeza es menor a
  este valor, entendemos que la snake se está chocando con sigo misma.
  */
  const normdistance=Distance(snake[0].x,snake[0].y,snake[1].x,snake[1].y);
  function sketchProc(processing) {

    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      document.getElementById("canvas").focus();
      processing.frameRate(30);
      processing.size(window.innerWidth-20, window.innerHeight-20);
      processing.background(10, 200, 50);
      processing.state = {
                          // Plump: segmento o segmentos del snake que están tragando algo
                          plump:[-1],
                          /* Eat: Determina si la serpiente se encuentra tragando o no.
                          De ser verdadero, ejecuta la función "eatSnake", que veremos más
                          adelante.
                          */
                          eat: false,
                          /* Over: Determina si el juego terminó o no.
                          De ser verdadero, la pantalla cambia a negro y aparece el mensaje
                          "GAME OVER".
                          */
                          over: false,
                          /* Kill: Determina si el juego debería terminar o no.
                          De ser verdadero, la snake se detiene y comienza a desintegrarse lentamente.
                          Al finalizar este proceso, over se vuelve verdadero, terminando el juego.
                          */
                          kill: false,
                          /* Dirección: La dirección que toma la cabeza de la serpiente.
                          En este proyecto, entendemos las direcciones como el número de pasos
                          que un objeto se mueve en el eje X y Y (La dirección izquierda vendría siendo X: -C y Y:0,
                          siendo C un número natural mayor que 0),
                          por tanto, la dirección es un objeto con los atributos X y Y.
                          */
                          dirección: {x: speed, y:0},
                          /* Snake: Nuestra snake. Como valor inicial,
                          copia la constante previamente definida de snake
                          */
                          snake: snake,
                          // Keydown: Determina si hay una tecla presionada
                          keydown:false,
                          // Key: Determina qué tecla está presionada, o qué tecla deja de estarlo.
                          key:processing.LEFT,
                          // Food: La comida, con atributos X y Y random dentro de los límites del canvas dibujado
                          food: 
                          {x: processing.random(50, window.innerWidth-70),
                          y: processing.random(50, window.innerHeight-70)},
                          // Score: El puntaje del usuario
                          score: 0,
                          // Twist: El twist de nuestra snake explicado previamente
                          twist: chosendif.twist,
                          /* Distance: La distancia entre la snake y la comida.
                          Si este valor llega a ser menor a la suma del radio de
                          la cabeza de la snake y el radio de la fruta, entendemos
                          que la snake se está comiendo la fruta.
                          */
                          distance: 50};
      
    }

    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo stado del mundo
    */
    processing.onTic = function (world) {
      if(world.keydown){
        switch (world.key) {
        
        
        case processing.LEFT:
        
          if (world.dirección.x>0&&world.dirección.y<=0)
        {
          if(world.dirección.y>-midval(speed))
          {
            return Movement(world,"y",-1,1);
          }
          return Movement(world,"x",-1,-1);
        }
        if (world.dirección.y<0)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return Movement(world,"x",-1,-1);
          }
          return Movement(world,"y",1,-1);
        }
        if (world.dirección.x<0)
        {
          if(world.dirección.y<midval(speed)&&world.dirección.y>=0)
          {
            return Movement(world,"y",1,-1);
          }
          return Movement(world,"x",1,1);
        }
        if (world.dirección.y>0)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return Movement(world,"x",1,1);
          }
          return Movement(world,"y",-1,1);
        }
        
        break;
        case processing.RIGHT:
        if (world.dirección.x>0&&world.dirección.y>=0)
        {
          if(world.dirección.y<midval(speed))
          {
            return Movement(world,"y",1,1);
          }
          return Movement(world,"x",-1,1);
        }
        if (world.dirección.y>0)
        {
          if(world.dirección.x>-midval(speed)&&world.dirección.x<=0)
          {
            return Movement(world,"x",-1,1);
          }
          return Movement(world,"y",-1,-1);
        }
        if (world.dirección.x<0)
        {
          if(world.dirección.y>-midval(speed)&&world.dirección.y<=0)
          {
            return Movement(world,"y",-1,-1);
          }
          return Movement(world,"x",1,-1);
        }
        if (world.dirección.y<0)
        {
          if(world.dirección.x<midval(speed)&&world.dirección.x>=0)
          {
            return Movement(world,"x",1,-1);
          }
          return Movement(world,"y",1,1);
        }
          break;
       
        
      }
      }
      return Movement(world,"nothing",null,null);
      
    }

    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch(keyCode)
      {
        case processing.UP:
          processing.loop();
          return make(world, {});
          break;
        case processing.DOWN:
          processing.textSize(100)
          processing.text("PAUSE", window.innerWidth/3, window.innerHeight/2);
          processing.noLoop();
          return make(world, {});
          break;
        case 32:
          return make(world, 
          {snake: 
          append(world.snake,
          [{x: last(world.snake).x+opposite(last(world.snake).dirección.x),
          y:last(world.snake).y+opposite(last(world.snake).dirección.y),
          dirección: last(world.snake).dirección}])});
        default:
        return make(world, {keydown: true, key:keyCode});
      }
      
    }
     processing.drawSnake = function (item)
  {
    if(!processing.state.kill)
    {
    processing.fill(245, 140, 42);
  }
  else{
    processing.fill(158, 155, 147);
  }
    processing.ellipse(item.x,item.y,size,size);
  }
  processing.eatSnake = function(item,index,array)
  {
    if(!processing.state.kill)
    {
    processing.fill(245, 140, 42);
  }
  else{
    processing.fill(158, 155, 147);
  }
    if(contain(index,processing.state.plump))
    {
      if(index==length(array)-1)
      {
        if(length(processing.state.plump)>1)
        {
          processing.state = make(processing.state, {plump: rest(processing.state.plump)});
        }
        else{
          processing.state = make(processing.state, {plump: [-1],eat: false});
        }
        processing.ellipse(item.x,item.y,size,size);
      processing.state = make(processing.state,
      {snake: 
      append(processing.state.snake,
      [{x: last(processing.state.snake).x+opposite(last(processing.state.snake).dirección.x),
      y:last(processing.state.snake).y+opposite(last(processing.state.snake).dirección.y),
      dirección: last(processing.state.snake).dirección,
      distance: 0}])});
      }
      else{
      processing.ellipse(item.x,item.y,
      size*1.5-(index*size*0.5)/length(array),
      size*1.5-(index*size*0.5)/length(array));
      }
      
    }
    
    else{
    processing.ellipse(item.x,item.y,size,size);
    }
  }
  processing.desintegrate = function (world)
  { 
    if (length(world.snake)==1)
    {
      processing.state = make(world, {over: true});
    }
    else{
    processing.state = make(world, {snake: restLast(world.snake)});
    processing.loop();
    }
    

  }
  processing.stop = function (item)
  {
    return make(item, {dirección: {x: 0,y: 0}});
  }
  processing.check = function (key)
  {
    if (window.localStorage.getItem(key)==null)
    {
      window.localStorage.setItem(puntdif(),"0");
    }
  }
 
 
  processing.offKeyEvent = function (world, keyCode){
    return make(world, {keydown: false, key:keyCode});
  }

    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world, txt) {
      processing.check(puntdif());
      if (world.score>parseInt(window.localStorage.getItem(puntdif())))
      {
        window.localStorage.setItem(puntdif(),""+world.score);
      }
      if (world.over==false)
      {
        processing.background(10, 200, 50);
      processing.fill(240, 240, 240);
      processing.state = make(world, {})
      if (selfColission(rest(world.snake),world.snake[0])&&world.kill==false)
      {
        processing.state = make(world, {eat: false,snake: world.snake.map(processing.stop), dirección: {x: 0, y: 0}});
        setTimeout(function(){processing.state=make(world, {kill: true})}, 1000);
      }
      if (world.distance<=size*2)
      {
        processing.state = make(world,
        {eat: true,
        score:world.score+100,
        food: 
        {x: processing.random(50, window.innerWidth-70),
        y: processing.random(50, window.innerHeight-70)},
        distance: 10});
      }
      if (world.kill)
      {
          processing.desintegrate(world);
      }
      if(world.eat)
      {
        processing.state = make(world,{plump: world.plump.map((x)=> x+1)});
        world.snake.forEach(processing.eatSnake);
        if (selfColission(rest(world.snake),world.snake[0])&&world.kill==false)
      {
        processing.state = make(world, {eat: false,snake: world.snake.map(processing.stop), dirección: {x: 0, y: 0}});
        processing.fill(158, 155, 147)
        setTimeout(function(){processing.state=make(world, {kill: true})}, 1000);
      }
      if (world.distance<=size*2)
      {
        processing.state = make(world,
        {plump: invertir(cons(-1,invertir(world.plump))),
        score:world.score+100,
        food: 
        {x: processing.random(50, window.innerWidth-70),
        y: processing.random(50, window.innerHeight-70)},
        distance: 10});

      }
      
        
      }
      else{
      world.snake.forEach(processing.drawSnake);
      }
      if (world.eat)
      {
        processing.fill(252, 114, 114);
      }
      else
      {
      processing.fill(245, 42, 42);
      }

      processing.ellipse(world.food.x,world.food.y,size*3,size*3);
      processing.textSize(20)
      processing.text(txt, 50, 200);
      processing.text("SCORE: "+world.score, 10, 30);
      processing.text("BEST SCORE: "+window.localStorage.getItem(puntdif()), 10, 70);
      }
      else
      {
        setTimeout(function(){
        processing.background(0,0,0);
        processing.textSize(150)
          processing.text("GAME OVER", window.innerWidth/6, window.innerHeight/2);
        },500);
      }
      
    }


    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state, processing.state.plump);
      processing.state = processing.onTic(processing.state);
    };

    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      if (!processing.state.over)
      {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
      }
    }

    processing.keyReleased = function () {
      processing.state = processing.offKeyEvent(processing.state, processing.keyCode);
    }

    
    
  }

  var canvas = document.getElementById("canvas");

  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>

